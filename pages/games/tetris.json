{
  "id": "tetris",
  "name": "테트리스",
  "description": "클래식한 블록 퍼즐 게임",
  "version": "1.0.0",
  "iconUrl": "https://example.com/icons/tetris.png",
  "fileSize": 0,
  "isBuiltIn": false,
  "categories": ["퍼즐", "액션", "클래식"],
  "lastUpdated": "2024-01-15T00:00:00Z",
  "gameType": "tetris",
  "config": {
    "rows": 20,
    "cols": 10,
    "speed": "medium"
  },
  "dartCode": "import 'package:flutter/material.dart';\nimport 'dart:async';\nimport 'dart:math';\n\nclass TetrisGame extends StatefulWidget {\n  const TetrisGame({super.key});\n\n  @override\n  State<TetrisGame> createState() => _TetrisGameState();\n}\n\nclass _TetrisGameState extends State<TetrisGame> {\n  static const int rows = 20;\n  static const int cols = 10;\n  List<List<int>> board = List.generate(rows, (_) => List.filled(cols, 0));\n  List<List<int>> currentPiece = [];\n  int currentRow = 0;\n  int currentCol = 0;\n  int score = 0;\n  int level = 1;\n  int linesCleared = 0;\n  bool isGameOver = false;\n  bool isPaused = false;\n  Timer? gameTimer;\n  final Random random = Random();\n\n  final List<List<List<int>>> pieces = [\n    [[1, 1, 1, 1]], // I\n    [[1, 1], [1, 1]], // O\n    [[0, 1, 0], [1, 1, 1]], // T\n    [[1, 1, 0], [0, 1, 1]], // S\n    [[0, 1, 1], [1, 1, 0]], // Z\n    [[1, 0, 0], [1, 1, 1]], // J\n    [[0, 0, 1], [1, 1, 1]], // L\n  ];\n\n  @override\n  void initState() {\n    super.initState();\n    _spawnPiece();\n    _startGame();\n  }\n\n  void _startGame() {\n    gameTimer = Timer.periodic(Duration(milliseconds: 500 - (level * 50).clamp(0, 400)), (timer) {\n      if (!isPaused && !isGameOver) {\n        _moveDown();\n      }\n    });\n  }\n\n  void _spawnPiece() {\n    currentPiece = pieces[random.nextInt(pieces.length)];\n    currentRow = 0;\n    currentCol = cols ~/ 2 - currentPiece[0].length ~/ 2;\n    \n    if (_checkCollision(currentRow, currentCol, currentPiece)) {\n      setState(() {\n        isGameOver = true;\n      });\n      gameTimer?.cancel();\n    }\n  }\n\n  bool _checkCollision(int row, int col, List<List<int>> piece) {\n    for (int i = 0; i < piece.length; i++) {\n      for (int j = 0; j < piece[i].length; j++) {\n        if (piece[i][j] == 1) {\n          int newRow = row + i;\n          int newCol = col + j;\n          if (newRow >= rows || newCol < 0 || newCol >= cols) return true;\n          if (newRow >= 0 && board[newRow][newCol] == 1) return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  void _placePiece() {\n    for (int i = 0; i < currentPiece.length; i++) {\n      for (int j = 0; j < currentPiece[i].length; j++) {\n        if (currentPiece[i][j] == 1) {\n          int row = currentRow + i;\n          int col = currentCol + j;\n          if (row >= 0) {\n            board[row][col] = 1;\n          }\n        }\n      }\n    }\n    _clearLines();\n    _spawnPiece();\n  }\n\n  void _clearLines() {\n    int cleared = 0;\n    for (int i = rows - 1; i >= 0; i--) {\n      if (board[i].every((cell) => cell == 1)) {\n        board.removeAt(i);\n        board.insert(0, List.filled(cols, 0));\n        cleared++;\n        i++;\n      }\n    }\n    if (cleared > 0) {\n      linesCleared += cleared;\n      score += cleared * 100 * level;\n      level = (linesCleared ~/ 10) + 1;\n      gameTimer?.cancel();\n      _startGame();\n    }\n  }\n\n  void _moveDown() {\n    if (_checkCollision(currentRow + 1, currentCol, currentPiece)) {\n      _placePiece();\n    } else {\n      setState(() {\n        currentRow++;\n      });\n    }\n  }\n\n  void _moveLeft() {\n    if (!_checkCollision(currentRow, currentCol - 1, currentPiece)) {\n      setState(() {\n        currentCol--;\n      });\n    }\n  }\n\n  void _moveRight() {\n    if (!_checkCollision(currentRow, currentCol + 1, currentPiece)) {\n      setState(() {\n        currentCol++;\n      });\n    }\n  }\n\n  List<List<int>> _rotatePiece(List<List<int>> piece) {\n    int rows = piece.length;\n    int cols = piece[0].length;\n    List<List<int>> rotated = List.generate(cols, (_) => List.filled(rows, 0));\n    for (int i = 0; i < rows; i++) {\n      for (int j = 0; j < cols; j++) {\n        rotated[j][rows - 1 - i] = piece[i][j];\n      }\n    }\n    return rotated;\n  }\n\n  void _rotate() {\n    List<List<int>> rotated = _rotatePiece(currentPiece);\n    if (!_checkCollision(currentRow, currentCol, rotated)) {\n      setState(() {\n        currentPiece = rotated;\n      });\n    }\n  }\n\n  void _hardDrop() {\n    while (!_checkCollision(currentRow + 1, currentCol, currentPiece)) {\n      currentRow++;\n    }\n    _placePiece();\n  }\n\n  void _togglePause() {\n    setState(() {\n      isPaused = !isPaused;\n    });\n  }\n\n  void _resetGame() {\n    setState(() {\n      board = List.generate(rows, (_) => List.filled(cols, 0));\n      score = 0;\n      level = 1;\n      linesCleared = 0;\n      isGameOver = false;\n      isPaused = false;\n    });\n    gameTimer?.cancel();\n    _spawnPiece();\n    _startGame();\n  }\n\n  @override\n  void dispose() {\n    gameTimer?.cancel();\n    super.dispose();\n  }\n\n  Color _getCellColor(int value) {\n    if (value == 1) return Colors.cyan;\n    return Colors.grey[200]!;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('테트리스')),\n      body: Column(\n        children: [\n          Padding(\n            padding: const EdgeInsets.all(16),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: [\n                Column(\n                  children: [\n                    Text('점수: $score', style: const TextStyle(fontSize: 18)),\n                    Text('레벨: $level', style: const TextStyle(fontSize: 16)),\n                    Text('라인: $linesCleared', style: const TextStyle(fontSize: 16)),\n                  ],\n                ),\n                if (isGameOver)\n                  ElevatedButton(\n                    onPressed: _resetGame,\n                    child: const Text('다시 시작'),\n                  )\n                else\n                  IconButton(\n                    icon: Icon(isPaused ? Icons.play_arrow : Icons.pause),\n                    onPressed: _togglePause,\n                  ),\n              ],\n            ),\n          ),\n          Expanded(\n            child: Center(\n              child: AspectRatio(\n                aspectRatio: cols / rows,\n                child: Container(\n                  margin: const EdgeInsets.all(16),\n                  decoration: BoxDecoration(\n                    border: Border.all(color: Colors.black, width: 2),\n                  ),\n                  child: CustomPaint(\n                    painter: TetrisPainter(\n                      board: board,\n                      currentPiece: currentPiece,\n                      currentRow: currentRow,\n                      currentCol: currentCol,\n                      rows: rows,\n                      cols: cols,\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          ),\n          if (isGameOver)\n            const Padding(\n              padding: EdgeInsets.all(16),\n              child: Text(\n                '게임 오버!',\n                style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: Colors.red),\n              ),\n            ),\n          Padding(\n            padding: const EdgeInsets.all(16),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                IconButton(\n                  icon: const Icon(Icons.arrow_back),\n                  onPressed: isGameOver || isPaused ? null : _moveLeft,\n                ),\n                IconButton(\n                  icon: const Icon(Icons.rotate_right),\n                  onPressed: isGameOver || isPaused ? null : _rotate,\n                ),\n                IconButton(\n                  icon: const Icon(Icons.arrow_downward),\n                  onPressed: isGameOver || isPaused ? null : _moveDown,\n                ),\n                IconButton(\n                  icon: const Icon(Icons.arrow_forward),\n                  onPressed: isGameOver || isPaused ? null : _moveRight,\n                ),\n                IconButton(\n                  icon: const Icon(Icons.vertical_align_bottom),\n                  onPressed: isGameOver || isPaused ? null : _hardDrop,\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass TetrisPainter extends CustomPainter {\n  final List<List<int>> board;\n  final List<List<int>> currentPiece;\n  final int currentRow;\n  final int currentCol;\n  final int rows;\n  final int cols;\n\n  TetrisPainter({\n    required this.board,\n    required this.currentPiece,\n    required this.currentRow,\n    required this.currentCol,\n    required this.rows,\n    required this.cols,\n  });\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final cellWidth = size.width / cols;\n    final cellHeight = size.height / rows;\n\n    // Draw board\n    for (int i = 0; i < rows; i++) {\n      for (int j = 0; j < cols; j++) {\n        final rect = Rect.fromLTWH(\n          j * cellWidth,\n          i * cellHeight,\n          cellWidth,\n          cellHeight,\n        );\n        final paint = Paint()..color = board[i][j] == 1 ? Colors.cyan : Colors.grey[200]!;\n        canvas.drawRect(rect, paint);\n        canvas.drawRect(rect, Paint()..color = Colors.black..style = PaintingStyle.stroke..strokeWidth = 1);\n      }\n    }\n\n    // Draw current piece\n    for (int i = 0; i < currentPiece.length; i++) {\n      for (int j = 0; j < currentPiece[i].length; j++) {\n        if (currentPiece[i][j] == 1) {\n          int row = currentRow + i;\n          int col = currentCol + j;\n          if (row >= 0 && row < rows && col >= 0 && col < cols) {\n            final rect = Rect.fromLTWH(\n              col * cellWidth,\n              row * cellHeight,\n              cellWidth,\n              cellHeight,\n            );\n            final paint = Paint()..color = Colors.blue;\n            canvas.drawRect(rect, paint);\n            canvas.drawRect(rect, Paint()..color = Colors.black..style = PaintingStyle.stroke..strokeWidth = 2);\n          }\n        }\n      }\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;\n}\n"
}

